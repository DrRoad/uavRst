if (!isGeneric('pc2dsm')) {
  setGeneric('pc2dsm', function(x, ...)
    standardGeneric('pc2dsm'))
}

#'@name pc2dsm
#'@title Create a Digital Surface Model from a UAV generated point cloud 
#'
#'@description
#' Create a Digital Surface Model from a UAV generated point cloud. Basically returns a  DSM. 
#' It uses the 'r.in.lidar' function to calculate LiDAR derived raster grids. 
#' It creates a \code{raster*} object. 
#' 
#' @seealso \href{https://grass.osgeo.org/grass70/manuals/r.in.lidar.html}{r.in.lidar help}
#'
#'@author Chris Reudenbach
#'
#'@param lasDir  default is \code{NULL} path  to the laz/las file(s)
#'@param gisdbase_path gisdbase will be linked or created depending on \code{gisdbase_exist}
#'@param GRASSlocation location will be linked or created depending on \code{gisdbase_exist}
#'@param projSubFolder subfolders that will be created/linked for R related GRASS processing 
#'@param grid_size resolution for raster operations 
#'@param type_smooth  default is \code{otb_gauss} alternatives are \code{saga_spline} or for no smoothing at all \code{no_smoothing}
#'@param saga_spline_level_max default is 9 number ob spline iterations
#'@param otb_gauss_radius default is \code{0.5} radius of otb smoothing filter in meter
#'@param dsm_minalt default is \code{0}, minimum DTM altitude accepted
#'@param dsm_area default \code{FALSE} generate polygon of valid DSM data 
#'@param proj4  default is EPSG \code{32632} any valid proj4 string that is assumingly the correct one
#'@param gisdbase_exist default is  \code{FALSE} switch if gisdbase is created or  linked only
#'@param giLinks  list of GI tools cli pathes as generated by a full call of link2GI
#'@param grass_lidar_method statistical method to sample the Lidar data
#'@param grass_lidar_pth grass lidar aggregation column percentile
#'@param dsm_maxalt  dsm maximum altitude
#'@param path_lastools path to LAStools binaries
#'@param verbose to be quiet (1)
#'@param cutExtent clip area


#'
#'
#'@export pc2dsm
#'@examples
#'\dontrun{
#' # create a DSM based on a uav point cloud 
#'  pc2dsm(lasDir =  lasDir,
#'         gisdbase_path = "~/temp6/GRASS7",
#'         GRASSlocation = "tmp/",
#'         projSubFolder = c("data/","output/","run/","las/"),
#'         grid_size = "0.05",
#'         gisdbase_exist = FALSE)
#'}
#'

pc2dsm <- function(lasDir = NULL,
                   gisdbase_path = NULL,
                   GRASSlocation = "tmp/",
                   projSubFolder = c("data/","output/","run/","las/"),
                   grid_size = "0.5", 
                   grass_lidar_method = "mean",
                   grass_lidar_pth = 90,
                   saga_spline_level_max = "5" ,
                   otb_gauss_radius = "0.5",
                   type_smooth = "otb_gauss",
                   dsm_minalt = 0,
                   dsm_maxalt = 4000,
                   dsm_area = FALSE,
                   cutExtent = NULL,
                   proj4 = "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs",
                   gisdbase_exist = FALSE,
                   path_lastools = NULL,
                   giLinks =NULL, 
                   verbose = TRUE) {
  
  if (is.null(giLinks)){
    giLinks <- linkBuilder()
  }
  
  gdal <- giLinks$gdal
  saga <- giLinks$saga
  sagaCmd<-saga$sagaCmd
  
  # get/map the las binary folder and create the base command line
  if (is.null(lasDir)) stop("no directory containing las/laz files provided...\n")
  lasDir <- path.expand(lasDir)
  if (Sys.info()["sysname"] == "Windows") {
    #cmd <- path_lastools <- paste(system.file(package = "uavRst"), "LAStools", sep="/")/LAStools/bin
    if (is.null(path_lastools)) {cmd <- path_lastools <- "C:/LAStools/bin"
    if (verbose) cat("\n You did not provide a path to your LAStool binary folder. Assuming C:/LAStools/bin\n")}
  } else {
    #cmd <- paste("wine ",path_lastools <- paste(system.file(package = "uavRst"), "LAStools",  sep="/"))
    if (is.null(path_lastools)) {cmd <- path_lastools <- paste0("wine ",path.expand("~/apps/LAStools/bin"))
    if (verbose) cat("\n You did not provide a path to your LAStool binary folder. Assuming wine ~/apps/LAStools/bin\n")}
    
  }
  #if (grep(pattern = "LAStools (by martin@rapidlasso.com)", ret, value = TRUE)) stop("no directory containing the Windows LAStool binary files is provided...\n")
  
  # command <- paste(cmd,"/lasinfo.exe ",sep = "/")
  # command <- paste0(command," -i ",lasFile)
  # command <- paste0(command," -h ")
  # command <- paste0(command," -stdout ")
  # ret <- system(command,intern = TRUE,ignore.stderr = F)
  # tmp <- grep(pattern = "rapidlasso", ret, value = TRUE)
  # grep(x = system(paste(cmd,"/lasinfo.exe -h",sep = "/"),intern = FALSE),pattern = "rapidlasso",ignore.case = TRUE)
  # 
  #create cmd strings
  lasmerge      <- paste(cmd,"lasmerge.exe",sep = "/")
  lasinfo       <- paste(cmd,"lasinfo.exe",sep = "/")
  las2dem       <- paste(cmd,"las2dem.exe",sep = "/")
  # delete content in run directory
  unlink(paste0(path_run,"*"), force = TRUE)
  
  setwd(path_run)  
  
  # some basic checks 
  
  if(raster::extension(basename(lasDir)) !=".las" & raster::extension(basename(lasDir)) !=".laz") {
    # check las / laz files laz will be preferred
    lasFileNames <- list.files(pattern = "[.]las$", path = lasDir, full.names = TRUE)
    lazFileNames <- list.files(pattern = "[.]laz$", path = lasDir, full.names = TRUE)
    if (length(lazFileNames) > 0 ) {
      extFN <- substr(raster::extension(basename(lazFileNames[1])),2,4)
      noF <- length(lazFileNames)
    }
    else if (length(lasFileNames) > 0) {
      extFN <- substr(raster::extension(basename(lasFileNames[1])),2,4)
      noF <- length(lasFileNames)
    }
    else stop("no valid las or laz files found...\n")
    # merge all files
    cat("\nNOTE: You are dealing with a huge UAV generated point cloud data set.\n      so take time and keep relaxed... :-)\n")
    cat(":: merge and decompress ",noF," point cloud files...\n")
    ret <- system(paste0(lasmerge,
                         " -i ",lasDir,"/*.",extFN,
                         " -olas",
                         " -o ",path_run,"full_point_cloud.las"),
                  intern = TRUE, 
                  ignore.stderr = TRUE
    )
  } else { 
    
    cat(":: decompress point cloud files...\n")
    
    cat("\n:: converting laz to las..\n")
    # build command
    command <- las2dem
    command <- paste0(command, " -i ",lasDir)
    command <- paste0(command," -odir ",path_run)
    command <- paste0(command," -olas")
    
    # execute
    ret <- system(command,intern = FALSE, ignore.stderr = FALSE)  
    
    
  }
  name<-"full_point_cloud.las"
  if (!is.null(cutExtent)){
  #lasTool(tool = "lasclip",lasFile = lasfile,cutExtent = cutExtent)
  las = lidR::readLAS(paste0(path_run,"full_point_cloud.las"))
  las_clip<-lidR::lasclipRectangle(las, as.numeric(cutExtent[1]), as.numeric(cutExtent[3]), as.numeric(cutExtent[2]), as.numeric(cutExtent[4]))
  lidR::writeLAS(las_clip ,paste0(path_run,"cut_point_cloud.las"))
  name<-"cut_point_cloud.las"
  }
  # get extent of merged file  
  sp_param <-lasTool(lasFile= paste0(path_run,name))
  
  # add proj4 string manually
  sp_param[5] <- proj4
  
  # create and export globally project folder structure
  paths<-link2GI::initProj(projRootDir = gisdbase_path, 
                           GRASSlocation = GRASSlocation, 
                           projFolders =  projSubFolder)
  
  # create GRASS7 connection according gisdbase_exist (permanent or temporary)
  if (gisdbase_exist)
    paths<-link2GI::linkGRASS7(gisdbase = gisdbase_path, location = GRASSlocation, gisdbase_exist = TRUE)  
  else 
    paths<-link2GI::linkGRASS7(gisdbase = gisdbase_path, location = GRASSlocation, spatial_params = sp_param,resolution = grid_size)  
  
  # create raw DSM using r.in.lidar
  cat(":: calculate DSM...\n")
  
  ret <- rgrass7::execGRASS("r.in.lidar",
                            flags  = c("overwrite","quiet","o"),
                            input  = paste0(path_run,name),
                            output = "point_cloud_dsm",
                            method = grass_lidar_method,
                            pth = grass_lidar_pth,
                            resolution = as.numeric(grid_size),
                            intern = TRUE,
                            ignore.stderr = TRUE
  )
  
  
  
  cat(":: convert raw DSM to GeoTiff \n")
  #h_grass2tif(runDir = path_output, layer = "point_cloud_dsm")
  raster::writeRaster(raster::raster(rgrass7::readRAST(paste0("point_cloud_dsm"))),paste0(path_output,"point_cloud_dsm"), overwrite=TRUE,format="GTiff")
  cat(":: preliminary fill of gaps... \n")
  #uavRst:::fillGaps(path_output,paste0("point_cloud_dsm.tif "))  
  ret <- system(paste0("gdal_fillnodata.py ",
                       path_output,"point_cloud_dsm.tif ",
                       path_output,"filled_point_cloud_dsm.tif"),intern = TRUE)
  
  gdalUtils::gdalwarp(paste0(path_output,"point_cloud_dsm.tif"), 
                      paste0(path_run,"point_cloud_dsm.sdat"), 
                      overwrite = TRUE,  
                      of = 'SAGA',
                      verbose = FALSE) 
  cat(":: smoothing the gap filled DSM... \n")
  # otb gaussian smooth
  if (type_smooth != "no_smoothing") { 
    if (type_smooth == "otb_gauss") {
      otb_gauss_radius <- as.character(as.numeric(otb_gauss_radius)/as.numeric(grid_size))
      otb <- link2GI::linkOTB()
      link2GI::makGlobalVar("path_OTB",otb$pathOTB)
      module  <- "otbcli_Smoothing"
      command <- paste0(path_OTB, module)
      command <- paste0(command, " -in ",path_output,"filled_point_cloud_dsm.tif")
      command <- paste0(command, " -out ", path_output, "/dsm.tif")
      command <- paste0(command, " -ram 4096")
      command <- paste0(command, " -type gaussian")
      command <- paste0(command, " -type.gaussian.radius ",otb_gauss_radius) #(in pixel)
      ret <- system(command, intern = TRUE)  
      dsm <- raster::raster(paste0(path_output, "/dsm.tif"))
    }
    if (type_smooth == "saga_spline") {
      # saga spline interpolation of the alt values
      cat(":: iterative spline smooth of dsm... \n")
      ret <- system(paste0(sagaCmd,' grid_spline 5 ',
                           ' -GRID ', path_run,'filled_point_cloud_dsm.sgrd',
                           ' -TARGET_DEFINITION 0',
                           ' -TARGET_OUT_GRID ',path_run,"spline_filled_point_cloud_dsm.sgrd",
                           ' -TARGET_USER_SIZE ',grid_size,
                           ' -METHOD 1',
                           ' -EPSILON 0.0001',
                           ' -LEVEL_MAX ',saga_spline_level_max),
                    intern = TRUE, 
                    ignore.stderr = TRUE)
      dsm <- gdalUtils::gdalwarp(paste0(path_run,"spline_filled_point_cloud_dsm.sdat"), 
                                 paste0(path_output,"dsm.tif"), 
                                 t_srs = proj4,
                                 output_Raster = TRUE,
                                 overwrite = TRUE,  
                                 verbose = FALSE) 
    }
  }
  cat(":: calculate metadata ... \n")
  dsm[dsm <= dsm_minalt] <- NA
  dsm[dsm > dsm_maxalt] <- NA
  raster::writeRaster(dsm, paste0(path_output, "dsm.tif"), overwrite = TRUE)
  e <- extent(dsm)
  dsmA <- as(e, 'SpatialPolygons')  
  if (dsm_area) {
    dsm2 <- dsm > -Inf
    tmp <- raster::aggregate(dsm2,fact = 1 / grid_size)
    dsmdA  <- rasterToPolygons(tmp)
    dsmdA  <- rgeos::gUnaryUnion(dsmdA)
    #dsmdA <- rasterToPolygons(dsm2, dissolve=TRUE)
  }
  else dsmdA <- NULL
  
  
  return(list(dsm,dsmA,dsmdA))
}
